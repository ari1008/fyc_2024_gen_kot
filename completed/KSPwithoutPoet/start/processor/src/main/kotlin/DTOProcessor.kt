package fr.esgi

import com.google.devtools.ksp.getDeclaredProperties
import com.google.devtools.ksp.processing.*
import com.google.devtools.ksp.symbol.*
import com.google.devtools.ksp.validate
import java.io.OutputStream

class DTOProcessor(
    private val codeGenerator: CodeGenerator,
    private val logger: KSPLogger
) : SymbolProcessor {

    override fun process(resolver: Resolver): List<KSAnnotated> {
        logger.warn("DTOProcessor starting processing...")

        // Récupérer toutes les classes annotées avec DTOAnnotation
        val symbols = resolver.getSymbolsWithAnnotation(DTOAnnotation::class.qualifiedName.toString())
            .filterIsInstance<KSClassDeclaration>()

        if (!symbols.iterator().hasNext()) {
            logger.warn("No other classes found with @${DTOAnnotation::class.qualifiedName.toString()}")
            return emptyList()
        }

        // Créer un fichier de sortie
        val file: OutputStream = codeGenerator.createNewFile(
            dependencies = Dependencies(false, *resolver.getAllFiles().toList().toTypedArray()),
            packageName = "fr.esgi.generated",
            fileName = "GeneratedDTOs"
        )

        // Écrire un header pour le fichier généré
        file.write("package fr.esgi.generated\n\n".toByteArray())
        file.write("// Automatically generated by KSP\n".toByteArray())

        // Parcourir chaque classe annotée
        symbols.forEach { classDeclaration ->
            if (!classDeclaration.validate()) return@forEach
            logger.warn("class name: $classDeclaration")
            classDeclaration.accept(DTOVisitor(file), Unit)
        }

        // Fermer le fichier
        file.close()

        return symbols.filterNot { it.validate() }.toList()
    }

    inner class DTOVisitor(private val file: OutputStream) : KSVisitorVoid() {
        override fun visitClassDeclaration(classDeclaration: KSClassDeclaration, data: Unit) {
            val className = classDeclaration.simpleName.asString()
            val dtoClassName = "${className}DTO"

            logger.warn("Generating DTO for class: $className")

            // Génération de la data class
            file.write("data class $dtoClassName(\n".toByteArray())

            classDeclaration.getDeclaredProperties().forEach { property ->
                visitPropertyDeclaration(property, data)

            }

            file.write(")\n\n".toByteArray())
        }

        override fun visitPropertyDeclaration(property: KSPropertyDeclaration, data: Unit) {

            val isAnnotated = property.annotations.any {
                it.shortName.getShortName() == "RemoveFromDTO"
            }
            if (!isAnnotated) {
                val propName = property.simpleName.asString()
                val propType = resolveType(property.type.resolve())
                file.write("    val $propName: $propType,\n".toByteArray())
            }

        }

        private fun resolveType(type: KSType): String {
            val typeName = type.declaration.simpleName.asString()
            if (type.arguments.isEmpty()) return typeName

            val genericArgs = type.arguments.joinToString(", ") {
                resolveType(it.type?.resolve() ?: return@joinToString "Any")
            }

            return "$typeName<$genericArgs>"
        }



    }
}